{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#pulseseek.pauli","title":"pauli","text":"<pre><code>pauli()\n</code></pre> <p>Return the Pauli matrices</p> <p>Returns:</p> Type Description <code>tuple[Hermitian, Hermitian, Hermitian]</code> <p>tuple[Hermitian, Hermitian, Hermitian]: the Pauli matrices.</p> Source code in <code>pulseseek/util.py</code> <pre><code>def pauli() -&gt; tuple[Hermitian, Hermitian, Hermitian]:\n    \"\"\"Return the Pauli matrices\n\n    Returns:\n        tuple[Hermitian, Hermitian, Hermitian]: the Pauli matrices.\n    \"\"\"\n    X = jnp.array([[0, 1], [1, 0]])\n    Y = jnp.array([[0, -1j], [1j, 0]])\n    Z = jnp.array([[1, 0], [0, -1]])\n\n    assert is_hermitian(X)\n    assert is_hermitian(Y)\n    assert is_hermitian(Z)\n\n    return X, Y, Z\n</code></pre>"},{"location":"api/#pulseseek.algebra","title":"algebra","text":""},{"location":"api/#pulseseek.algebra.lie_closure","title":"lie_closure","text":"<pre><code>lie_closure(elements, bracket=matrix_commutator, name_element=lambda idx: f'_A{idx}', max_rank=100)\n</code></pre> <p>Construct a basis closed under the Lie bracket that spans the elements.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Mapping[str, Any]</code> <p>the elements to span.  The keys should be the names of the elements and the values should be the elements themselves.  The elements must be square matrices.</p> required <code>bracket</code> <code>MatrixBracket</code> <p>the Lie bracket. Defaults to matrix_commutator.</p> <code>matrix_commutator</code> <code>name_element</code> <code>NameElement</code> <p>A callback function that is used to generate names of created algebra elements. Defaults to <code>lambda idx: f\"_A{idx}\"</code>.</p> <code>lambda idx: f'_A{idx}'</code> <code>max_rank</code> <code>int</code> <p>the maximum rank of the generated Lie algebra.  If the rank exceeds max_rank, the function raises a ValueError.  Defaults to 100.</p> <code>100</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the rank of the generated algebra exceeds max_rank</p> <p>Returns:</p> Name Type Description <code>LieBasis</code> <code>LieBasis</code> <p>the spanning basis</p> Source code in <code>pulseseek/algebra.py</code> <pre><code>def lie_closure(\n    elements: Mapping[str, Any],\n    bracket: MatrixBracket = matrix_commutator,\n    name_element: NameElement = lambda idx: f\"_A{idx}\",\n    max_rank: int = 100,\n) -&gt; LieBasis:\n    \"\"\"Construct a basis closed under the Lie bracket that spans the elements.\n\n    Args:\n        elements (Mapping[str, Any]): the elements to span.  The keys should be\n            the names of the elements and the values should be the elements\n            themselves.  The elements must be square matrices.\n        bracket (MatrixBracket, optional): the Lie bracket. Defaults to\n            matrix_commutator.\n        name_element (NameElement, optional): A callback function that is used\n            to generate names of created algebra elements. Defaults to\n            `lambda idx: f\"_A{idx}\"`.\n        max_rank (int, optional): the maximum rank of the generated Lie\n            algebra.  If the rank exceeds max_rank, the function raises a\n            ValueError.  Defaults to 100.\n\n    Raises:\n        ValueError: if the rank of the generated algebra exceeds max_rank\n\n    Returns:\n        LieBasis: the spanning basis\n    \"\"\"\n\n    def in_span(x: SquareMatrix, vectors: Iterable[SquareMatrix], atol=1e-12) -&gt; bool:\n        \"\"\"Check if x is in the span of vectors.\"\"\"\n        vecs = tuple(vectors)\n        if len(vecs) == 0:\n            return False\n\n        V = np.column_stack([M.reshape(-1) for M in vecs])\n        X = x.reshape(-1)\n\n        rank_V = np.linalg.matrix_rank(V, tol=atol)\n        rank_aug = np.linalg.matrix_rank(np.column_stack([V, X]), tol=atol)\n        return rank_V == rank_aug\n\n    def brackets(\n        vectors: Iterable[SquareMatrix],\n    ) -&gt; Generator[SquareMatrix, None, None]:\n        \"\"\"Iterate over Lie brackets.\"\"\"\n        for a, x in enumerate(vectors):\n            for b, y in enumerate(vectors):\n                if a != b:\n                    yield bracket(x, y)\n\n    def new_elements(\n        vectors: Iterable[SquareMatrix], max_rank: int\n    ) -&gt; dict[str, SquareMatrix]:\n        \"\"\"Generate new elements in one round of repeated Lie brackets.\"\"\"\n        v = list(vectors)\n        elements: dict[str, SquareMatrix] = {}\n        idx = 0\n\n        for E in brackets(v):\n            if not in_span(E, v):\n                v.append(E)\n                name = name_element(idx)\n                idx += 1\n                elements[name] = E\n\n            if len(v) &gt; max_rank:\n                raise ValueError(\n                    \"Maximum rank exceeded, Lie algebra may be infinite rank\"\n                )\n        return elements\n\n    def linearly_independent_elements(\n        elements: Mapping[str, SquareMatrix],\n    ) -&gt; dict[str, SquareMatrix]:\n        \"\"\"Select the linearly independent elements.\"\"\"\n        independent: dict[str, SquareMatrix] = {}\n        for name, E in elements.items():\n            if not in_span(E, independent.values()):\n                independent[name] = E\n        return independent\n\n    U = linearly_independent_elements(elements)\n    V = new_elements(U.values(), max_rank)\n    closure = {**U, **V}\n\n    while True:\n        V = new_elements(closure.values(), max_rank)\n        if len(V) == 0:\n            break\n        closure = {**closure, **V}\n\n    return LieBasis.new(closure)\n</code></pre>"},{"location":"api/#pulseseek.algebra.gram_matrix","title":"gram_matrix","text":"<pre><code>gram_matrix(basis, inner_product=hilbert_schmidt_inner_product)\n</code></pre> <p>Calculate the Gram matrix of a Lie basis</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>LieBasis</code> <p>the Lie basis</p> required <code>inner_product</code> <code>MatrixInnerProduct</code> <p>the inner product. Defaults to hilbert_schmidt_inner_product.</p> <code>hilbert_schmidt_inner_product</code> <p>Returns:</p> Name Type Description <code>Hermitian</code> <code>Hermitian</code> <p>the Gram matrix</p> Source code in <code>pulseseek/algebra.py</code> <pre><code>def gram_matrix(\n    basis: LieBasis, inner_product: MatrixInnerProduct = hilbert_schmidt_inner_product\n) -&gt; Hermitian:\n    \"\"\"Calculate the Gram matrix of a Lie basis\n\n    Args:\n        basis (LieBasis): the Lie basis\n        inner_product (MatrixInnerProduct, optional): the inner product.\n            Defaults to hilbert_schmidt_inner_product.\n\n    Returns:\n        Hermitian: the Gram matrix\n    \"\"\"\n    m = basis.dim\n    G = np.zeros((m, m))\n    for a in range(m):\n        for b in range(m):\n            A = basis[a]\n            B = basis[b]\n            G[a, b] = inner_product(A, B)\n    Gr = jnp.array(G)\n    assert is_hermitian(Gr, dimension=m)\n    return Gr\n</code></pre>"},{"location":"api/#pulseseek.algebra.structure_constants","title":"structure_constants","text":"<pre><code>structure_constants(basis, inner_product=hilbert_schmidt_inner_product, bracket=matrix_commutator)\n</code></pre> <p>Calculate the structure constant tensor for a Lie basis</p> <p>Note</p> <p>The elements of the structure constant tensor are defined as</p> \\[ F_{a b c} = \\langle E_a, [ E_b, E_c ] \\rangle \\] <p>where E_a, E_b, and E_c are Lie basis elements.  Using the Einstein summation notation, if we expand two arbitrary elements <code>P</code>, <code>Q</code> in terms of the Lie basis <code>P = P_i E_i</code> and <code>Q = Q_j E_j</code>, then their bracket may be written as</p> \\[ [P, Q] = P_i Q_i F_{k i j} E_k \\] <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>LieBasis</code> <p>the Lie basis</p> required <code>inner_product</code> <code>MatrixInnerProduct</code> <p>the inner product. Defaults to hilbert_schmidt_inner_product.</p> <code>hilbert_schmidt_inner_product</code> <code>bracket</code> <code>MatrixBracket</code> <p>the Lie bracket. Defaults to matrix_commutator.</p> <code>matrix_commutator</code> <p>Returns:</p> Name Type Description <code>AntiSymmetricTensor</code> <code>AntiSymmetricTensor</code> <p>the structure constant tensor</p> Source code in <code>pulseseek/algebra.py</code> <pre><code>def structure_constants(\n    basis: LieBasis,\n    inner_product: MatrixInnerProduct = hilbert_schmidt_inner_product,\n    bracket: MatrixBracket = matrix_commutator,\n) -&gt; AntiSymmetricTensor:\n    \"\"\"Calculate the structure constant tensor for a Lie basis\n\n    !!! note\n\n        The elements of the structure constant tensor are defined as\n\n        $$ F_{a b c} = \\\\langle E_a, [ E_b, E_c ] \\\\rangle $$\n\n        where E_a, E_b, and E_c are Lie basis elements.  Using the Einstein\n        summation notation, if we expand two arbitrary elements `P`, `Q` in\n        terms of the Lie basis `P = P_i E_i` and `Q = Q_j E_j`, then their\n        bracket may be written as\n\n        $$ [P, Q] = P_i Q_i F_{k i j} E_k $$\n\n    Args:\n        basis (LieBasis): the Lie basis\n        inner_product (MatrixInnerProduct, optional): the inner product.\n            Defaults to hilbert_schmidt_inner_product.\n        bracket (MatrixBracket, optional): the Lie bracket. Defaults to\n            matrix_commutator.\n\n    Returns:\n        AntiSymmetricTensor: the structure constant tensor\n    \"\"\"\n    m = basis.dim\n    S = np.zeros((m, m, m))\n    G = gram_matrix(basis, inner_product)\n    Ginv = jnp.linalg.inv(G)\n\n    for b, B in enumerate(basis.elements):\n        for c, C in enumerate(basis.elements):\n            ad_B_C = bracket(B, C)\n            for a, A in enumerate(basis.elements):\n                S[a, b, c] = inner_product(A, ad_B_C)\n\n    F = jnp.einsum(\"ad,dbc-&gt;abc\", Ginv, S, optimize=True)\n    assert is_antisymmetric_tensor(F, dimension=m)\n    return F\n</code></pre>"},{"location":"api/#pulseseek.algebra.lie_inner_product","title":"lie_inner_product  <code>cached</code>","text":"<pre><code>lie_inner_product(algebra)\n</code></pre> <p>Construct the inner product function for the algebra</p> <p>Parameters:</p> Name Type Description Default <code>algebra</code> <code>LieAlgebra</code> <p>the Lie algebra</p> required <p>Returns:</p> Name Type Description <code>LieInnerProduct</code> <code>LieInnerProduct</code> <p>the inner product</p> Source code in <code>pulseseek/algebra.py</code> <pre><code>@functools.cache\ndef lie_inner_product(algebra: LieAlgebra) -&gt; LieInnerProduct:\n    \"\"\"Construct the inner product function for the algebra\n\n    Args:\n        algebra (LieAlgebra): the Lie algebra\n\n    Returns:\n        LieInnerProduct: the inner product\n    \"\"\"\n    G = algebra.G\n\n    @jax.jit\n    def inner_product(x: LieVector, y: LieVector) -&gt; Scalar:\n        ip = x @ G @ y\n        return ip\n\n    return inner_product\n</code></pre>"},{"location":"api/#pulseseek.algebra.lie_bracket","title":"lie_bracket  <code>cached</code>","text":"<pre><code>lie_bracket(algebra)\n</code></pre> <p>Construct the Lie bracket function for the algebra</p> <p>Parameters:</p> Name Type Description Default <code>algebra</code> <code>LieAlgebra</code> <p>the Lie algebra</p> required <p>Returns:</p> Name Type Description <code>LieBracket</code> <code>LieBracket</code> <p>the lie bracket</p> Source code in <code>pulseseek/algebra.py</code> <pre><code>@functools.cache\ndef lie_bracket(algebra: LieAlgebra) -&gt; LieBracket:\n    \"\"\"Construct the Lie bracket function for the algebra\n\n    Args:\n        algebra (LieAlgebra): the Lie algebra\n\n    Returns:\n        LieBracket: the lie bracket\n    \"\"\"\n    F = algebra.F\n\n    @jax.jit\n    def bracket(x: LieVector, y: LieVector) -&gt; LieVector:\n        z = jnp.einsum(\"kij,i,j-&gt;k\", F, x, y, optimize=True)\n        return z\n\n    return bracket\n</code></pre>"},{"location":"api/#pulseseek.algebra.lie_adjoint_action","title":"lie_adjoint_action  <code>cached</code>","text":"<pre><code>lie_adjoint_action(algebra, atol=1e-12, max_terms=1000)\n</code></pre> <p>Construct the adjoint action of a Lie algebra</p> <p>Note</p> <p>If <code>a</code>, <code>b</code> are Lie algebra vectors then</p> \\[ \\exp(a) b \\exp(-a) = Ad_{\\exp(a)}(b) \\] <p>is the adjoint action.</p> <p>Parameters:</p> Name Type Description Default <code>algebra</code> <code>LieAlgebra</code> <p>the Lie algebra</p> required <code>atol</code> <code>float</code> <p>the absolute tolerance. Defaults to 1e-12.</p> <code>1e-12</code> <code>max_terms</code> <code>int</code> <p>the maximum number of terms. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>LieBracket</code> <code>LieBracket</code> <p>the adjoint action function</p> Source code in <code>pulseseek/algebra.py</code> <pre><code>@functools.cache\ndef lie_adjoint_action(\n    algebra: LieAlgebra, atol: float = 1e-12, max_terms: int = 1000\n) -&gt; LieBracket:\n    \"\"\"Construct the adjoint action of a Lie algebra\n\n    !!! note\n\n        If `a`, `b` are Lie algebra vectors then\n\n        $$ \\\\exp(a) b \\\\exp(-a) = Ad_{\\\\exp(a)}(b) $$\n\n        is the adjoint action.\n\n    Args:\n        algebra (LieAlgebra): the Lie algebra\n        atol (float, optional): the absolute tolerance. Defaults to 1e-12.\n        max_terms (int, optional): the maximum number of terms. Defaults to\n            1000.\n\n    Returns:\n        LieBracket: the adjoint action function\n    \"\"\"\n    inner_product = lie_inner_product(algebra)\n    bracket = lie_bracket(algebra)\n\n    # @jax.jit\n    def adjoint_action_horner(x: LieVector, y: LieVector) -&gt; LieVector:\n        \"\"\"Computes the Taylor series of Ad_{exp(x)} y using Horner's method.\n\n        Args:\n            x (Vector): Lie algebra vector\n            y (Vector): Lie algebra vector\n\n        Returns:\n            Vector: the adjoint action\n        \"\"\"\n        eps = jnp.array(atol)\n\n        def body(carry: LieAdjointCarry) -&gt; LieAdjointCarry:\n            n = carry.n + 1\n            term = bracket(x, carry.term) / n\n            result = carry.result + term\n            return LieAdjointCarry(result, term, n)\n\n        def cond(carry: LieAdjointCarry) -&gt; jax.Array:\n            norm = jnp.real(jnp.sqrt(inner_product(carry.term, carry.term)))\n            is_not_converged = jnp.array(norm &gt;= eps).reshape(())\n            is_not_done = jnp.array(carry.n &lt; max_terms).reshape(())\n            return jnp.logical_and(is_not_converged, is_not_done)\n\n        n = jnp.array([0])\n        initial = LieAdjointCarry(y, y, n)\n        final = jax.lax.while_loop(cond, body, initial)\n        return final.result\n\n    return adjoint_action_horner\n</code></pre>"},{"location":"api/#pulseseek.basis","title":"basis","text":""},{"location":"api/#pulseseek.basis.LieBasis","title":"LieBasis  <code>dataclass</code>","text":"<pre><code>LieBasis(ndim, _labels, _elements, _index)\n</code></pre>"},{"location":"api/#pulseseek.basis.LieBasis.elements","title":"elements  <code>property</code>","text":"<pre><code>elements\n</code></pre> <p>The Lie algebra basis vectors in their matrix representation</p> <p>Returns:</p> Type Description <code>tuple[SquareMatrix, ...]</code> <p>tuple[SquareMatrix, ...]: the matrix representations</p>"},{"location":"api/#pulseseek.basis.LieBasis.vectors","title":"vectors  <code>property</code>","text":"<pre><code>vectors\n</code></pre> <p>The Lie algebra basis vectors</p> <p>Returns:</p> Type Description <code>tuple[LieVector, ...]</code> <p>tuple[LieVector, ...]: the basis vectors</p>"},{"location":"api/#pulseseek.basis.LieBasis.zero","title":"zero  <code>property</code>","text":"<pre><code>zero\n</code></pre> <p>The zero vector on the Lie algebra</p> <p>Returns:</p> Name Type Description <code>LieVector</code> <code>LieVector</code> <p>the zero vector</p>"},{"location":"api/#pulseseek.basis.LieBasis.dim","title":"dim  <code>property</code>","text":"<pre><code>dim\n</code></pre> <p>The dimension (rank) of the Lie algebra</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the dimension</p>"},{"location":"api/#pulseseek.basis.LieBasis.matrix","title":"matrix","text":"<pre><code>matrix(x)\n</code></pre> <p>The matrix representation of a Lie algebra vector</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>LieVector</code> <p>the Lie algebra vector</p> required <p>Returns:</p> Name Type Description <code>SquareMatrix</code> <code>SquareMatrix</code> <p>the matrix representation of xs</p> Source code in <code>pulseseek/basis.py</code> <pre><code>def matrix(self, x: LieVector) -&gt; SquareMatrix:\n    \"\"\"The matrix representation of a Lie algebra vector\n\n    Args:\n        x (LieVector): the Lie algebra vector\n\n    Returns:\n        SquareMatrix: the matrix representation of xs\n    \"\"\"\n\n    def matrix_sum(a: SquareMatrix, b: SquareMatrix) -&gt; SquareMatrix:\n        return a + b\n\n    return functools.reduce(\n        matrix_sum, (xi * ei for xi, ei in zip(x, self.elements))\n    )\n</code></pre>"},{"location":"api/#pulseseek.basis.basis_vector","title":"basis_vector","text":"<pre><code>basis_vector(b: int, index: int) -&gt; LieVector\n</code></pre><pre><code>basis_vector(b: LieBasis, index: int) -&gt; LieVector\n</code></pre> <pre><code>basis_vector(b, index)\n</code></pre> <p>Construct a Lie basis vector</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>int | LieBasis</code> <p>the basis or the rank of the algebra</p> required <code>index</code> <code>int</code> <p>the basis vector index</p> required <p>Returns:</p> Name Type Description <code>Vector</code> <code>LieVector</code> <p>the basis vector</p> Source code in <code>pulseseek/basis.py</code> <pre><code>def basis_vector(b: \"int | LieBasis\", index: int) -&gt; LieVector:\n    \"\"\"Construct a Lie basis vector\n\n    Args:\n        b (int | LieBasis): the basis or the rank of the algebra\n        index (int): the basis vector index\n\n    Returns:\n        Vector: the basis vector\n    \"\"\"\n    dim = b.dim if isinstance(b, LieBasis) else b\n    e = np.zeros((dim,), dtype=float)\n    e[index] = 1.0\n    ev = jnp.array(e)\n    assert is_vector(ev)\n    return ev\n</code></pre>"},{"location":"api/#pulseseek.basis.pauli_basis","title":"pauli_basis","text":"<pre><code>pauli_basis()\n</code></pre> <p>The Pauli operator basis for the su(2) algebra</p> <p>Returns:</p> Name Type Description <code>LieBasis</code> <code>LieBasis</code> <p>the Pauli basis</p> Source code in <code>pulseseek/basis.py</code> <pre><code>def pauli_basis() -&gt; LieBasis:\n    \"\"\"The Pauli operator basis for the su(2) algebra\n\n    Returns:\n        LieBasis: the Pauli basis\n    \"\"\"\n    X, Y, Z = pauli()\n    return LieBasis.new({\"iX\": 1j * X, \"iY\": 1j * Y, \"iZ\": 1j * Z})\n</code></pre>"},{"location":"api/#pulseseek.basis.heisenburg_basis","title":"heisenburg_basis","text":"<pre><code>heisenburg_basis()\n</code></pre> <p>Heisenburg algebra using traditional basis.</p> <p>Note</p> <p>See the Wikipedia page on the Heisenburg algebra</p> <p>Returns:</p> Name Type Description <code>LieBasis</code> <code>LieBasis</code> <p>the Lie basis for the Heisenburg algebra</p> Source code in <code>pulseseek/basis.py</code> <pre><code>def heisenburg_basis() -&gt; LieBasis:\n    \"\"\"Heisenburg algebra using traditional basis.\n\n    !!! note\n\n        See the Wikipedia page on the [Heisenburg algebra](https://en.wikipedia.org/wiki/Heisenberg_group#Heisenberg_algebra)\n\n    Returns:\n        LieBasis: the Lie basis for the Heisenburg algebra\n    \"\"\"\n    X = jnp.array([[0, 1, 0], [0, 0, 0], [0, 0, 0]])\n    Y = jnp.array([[0, 0, 0], [0, 0, 1], [0, 0, 0]])\n    Z = jnp.array([[0, 0, 1], [0, 0, 0], [0, 0, 0]])\n    elements = {\"X\": X, \"Y\": Y, \"Z\": Z}\n    return LieBasis.new(elements)\n</code></pre>"},{"location":"api/#pulseseek.basis.fock_basis","title":"fock_basis","text":"<pre><code>fock_basis(ndim=15)\n</code></pre> <p>Heisenburg algebra using a truncated Fock state representation.</p> <p>Parameters:</p> Name Type Description Default <code>ndim</code> <code>int</code> <p>Dimension of the truncated Fock state. Defaults to 15.</p> <code>15</code> <p>Returns:</p> Name Type Description <code>LieBasis</code> <code>LieBasis</code> <p>the Lie basis for the Heisenburg algebra</p> Source code in <code>pulseseek/basis.py</code> <pre><code>def fock_basis(ndim: int = 15) -&gt; LieBasis:\n    \"\"\"Heisenburg algebra using a truncated Fock state representation.\n\n    Args:\n        ndim (int, optional): Dimension of the truncated Fock state. Defaults\n            to 15.\n\n    Returns:\n        LieBasis: the Lie basis for the Heisenburg algebra\n    \"\"\"\n\n    def annihilation() -&gt; SquareMatrix:\n        a = np.zeros((ndim, ndim))\n        for n in range(1, ndim):\n            a[n - 1, n] = np.sqrt(n)\n        A = jnp.array(a)\n        assert is_square_matrix(A)\n        return A\n\n    def identity() -&gt; SquareMatrix:\n        I = jnp.array(np.eye(ndim))\n        assert is_square_matrix(I)\n        return I\n\n    A = annihilation()\n    Id = identity()\n    elements = {\"a\": A, \"a\u2020\": A.T.conj(), \"I\": Id}\n    return LieBasis.new(elements)\n</code></pre>"},{"location":"api/#pulseseek.bch","title":"bch","text":""},{"location":"api/#pulseseek.bch.BilinearMap","title":"BilinearMap  <code>module-attribute</code>","text":"<pre><code>BilinearMap = Callable[[LieVector, LieVector], LieVector]\n</code></pre> <p>A bilinear mapping between Lie algebra vectors.</p>"},{"location":"api/#pulseseek.bch.BCHTerms","title":"BCHTerms  <code>module-attribute</code>","text":"<pre><code>BCHTerms = tuple[LieVector, ...]\n</code></pre> <p>Terms of the BCH expansion. The cumulative sum converges to  <code>log(exp(t x) exp(t y))</code> when <code>t</code> is small.</p>"},{"location":"api/#pulseseek.bch.BCHOperationFlag","title":"BCHOperationFlag  <code>module-attribute</code>","text":"<pre><code>BCHOperationFlag = Literal['X', 'Y', 'BR']\n</code></pre> <p>A flag describing the interpreted symbol in the BCH DSL language.  Flags are used to build a set of instructions that are compiled into a JAX function for the BCH term.</p>"},{"location":"api/#pulseseek.bch.BCHLifting","title":"BCHLifting  <code>module-attribute</code>","text":"<pre><code>BCHLifting = Matrix\n</code></pre> <p>The multilinear lifting of the arguments of a BCH term.  The multilinear lifting of a sequence of Lie vectors <code>x_1</code>, <code>x_2</code>, ... <code>x_p</code> is the column-stacked matrix <code>[x_1, x_2, ..., x_p]</code>.</p>"},{"location":"api/#pulseseek.bch.BCHLiftingMap","title":"BCHLiftingMap  <code>module-attribute</code>","text":"<pre><code>BCHLiftingMap = Callable[[BCHLifting, BCHLifting], LieVector]\n</code></pre> <p>A bilinear mapping operating on the multilinear lifting of a BCH term.</p>"},{"location":"api/#pulseseek.bch.BCHLiftingSeries","title":"BCHLiftingSeries  <code>module-attribute</code>","text":"<pre><code>BCHLiftingSeries = tuple[BCHLiftingMap, ...]\n</code></pre> <p>A sequence of bilinear maps that produce BCH-family terms.</p>"},{"location":"api/#pulseseek.bch.BCHMonomial","title":"BCHMonomial  <code>dataclass</code>","text":"<pre><code>BCHMonomial(order, degree_x, degree_y, coeff, term)\n</code></pre> <p>A single BCH bracket monomial (no sums), bihomogeneous in (x, y).</p> <p>Note</p> <p>This object represents one nested Lie-bracket expression built from <code>p</code> copies of <code>x</code> and <code>q</code> copies of <code>y</code> (e.g., <code>[x, [x, y]]</code>). As a multilinear map in its <code>p + q</code> formal arguments it is linear in each slot; after identifying all x-slots with the same x and all y-slots with the same y, the resulting map <code>(x, y) \u21a6 T(x, y)</code> is bihomogeneous of bidegree <code>(p, q)</code>:</p> \\[ T(a x, b y) = a^p b^q T(x, y) \\] <p>for all scalars <code>a</code>, <code>b</code>.</p>"},{"location":"api/#pulseseek.bch.BCHCompilerPrimitives","title":"BCHCompilerPrimitives","text":"<p>               Bases: <code>NamedTuple</code>, <code>Generic[T]</code></p> <p>A data structure storing factory functions to produce BCH primitives</p>"},{"location":"api/#pulseseek.bch.baker_campbell_hausdorff_compile","title":"baker_campbell_hausdorff_compile  <code>cached</code>","text":"<pre><code>baker_campbell_hausdorff_compile(bracket: LieBracket, max_order: int = ..., mode: Literal['standard'] = ...) -&gt; dict[tuple[int, int], BilinearMap]\n</code></pre><pre><code>baker_campbell_hausdorff_compile(bracket: LieBracket, max_order: int = ..., mode: Literal['lifting'] = ...) -&gt; dict[tuple[int, int], BCHLiftingMap]\n</code></pre> <pre><code>baker_campbell_hausdorff_compile(bracket, max_order=BCH_MAX_ORDER, mode='standard')\n</code></pre> <p>Compile BCH Z_{(p, q)} functions using the Lie bracket</p> <p>Parameters:</p> Name Type Description Default <code>bracket</code> <code>LieBracket</code> <p>the Lie bracket.</p> required <code>max_order</code> <code>int</code> <p>the maximum BCH expansion order. Defaults to BCH_MAX_ORDER.</p> <code>BCH_MAX_ORDER</code> <code>mode</code> <code>str</code> <p>the mode of compilation. Defaults to \"standard\".</p> <code>'standard'</code> <p>Returns:</p> Type Description <code>dict[tuple[int, int], BilinearMap | BCHLiftingMap]</code> <p>dict[tuple[int, int], T]: A dictionary of JIT compiled functions. The keys are tuples <code>(p, q)</code> and the values are bilinear mapping functions on the Lie algebra.</p> Source code in <code>pulseseek/bch.py</code> <pre><code>@functools.cache\ndef baker_campbell_hausdorff_compile(\n    bracket: LieBracket,\n    max_order: int = BCH_MAX_ORDER,\n    mode: Literal[\"standard\", \"lifting\"] = \"standard\",\n) -&gt; dict[tuple[int, int], BilinearMap | BCHLiftingMap]:\n    \"\"\"Compile BCH Z_{(p, q)} functions using the Lie bracket\n\n    Args:\n        bracket (LieBracket): the Lie bracket.\n        max_order (int, optional): the maximum BCH expansion order. Defaults to\n            BCH_MAX_ORDER.\n        mode (str, optional): the mode of compilation. Defaults to \"standard\".\n\n    Returns:\n        dict[tuple[int, int], T]: A dictionary of JIT compiled functions. The\n            keys are tuples `(p, q)` and the values are bilinear mapping\n            functions on the Lie algebra.\n    \"\"\"\n    primitives = (\n        _bch_primitives(bracket)\n        if mode == \"standard\"\n        else _bch_lifting_primitives(bracket)\n    )\n    fns = {}\n\n    for polynomial in _iter_bch_polynomial(max_order):\n        _, degree_x, degree_y = _get_polynomial_order_degree(polynomial)\n        polynomial_fn = _compile_polynomial(primitives, polynomial)\n        fns[(degree_x, degree_y)] = polynomial_fn\n\n    return fns\n</code></pre>"},{"location":"api/#pulseseek.bch.baker_campbell_hausdorff","title":"baker_campbell_hausdorff","text":"<pre><code>baker_campbell_hausdorff(algebra, order=8)\n</code></pre> <p>Generate a function that computes the Baker-Campbell-Hausdorff series.</p> <p>Parameters:</p> Name Type Description Default <code>algebra</code> <code>LieAlgebra</code> <p>the Lie algebra</p> required <code>order</code> <code>int</code> <p>the maximum order. Defaults to 8.</p> <code>8</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>raised if the series order is invalid</p> <p>Returns:</p> Type Description <code>Callable[[LieVector, LieVector], BCHTerms]</code> <p>Callable[[Vector, Vector], BCHTerms]: function computing the series</p> Source code in <code>pulseseek/bch.py</code> <pre><code>def baker_campbell_hausdorff(\n    algebra: LieAlgebra, order: int = 8\n) -&gt; Callable[[LieVector, LieVector], BCHTerms]:\n    \"\"\"Generate a function that computes the Baker-Campbell-Hausdorff series.\n\n    Args:\n        algebra (LieAlgebra): the Lie algebra\n        order (int, optional): the maximum order. Defaults to 8.\n\n    Raises:\n        ValueError: raised if the series order is invalid\n\n    Returns:\n        Callable[[Vector, Vector], BCHTerms]: function computing the series\n    \"\"\"\n    bracket = lie_bracket(algebra)\n    series = baker_campbell_hausdorff_series(bracket)\n\n    if order + 1 &gt; len(series):\n        raise ValueError(\"order is greater than the maximum series order\")\n\n    @jax.jit\n    def bch(x: LieVector, y: LieVector) -&gt; BCHTerms:\n        return tuple(Zm(x, y) for Zm in series[0:order])\n\n    return bch\n</code></pre>"},{"location":"api/#pulseseek.polynomial","title":"polynomial","text":""},{"location":"api/#pulseseek.polynomial.LiePolynomial","title":"LiePolynomial","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A polynomial with coefficients on the Lie algebra</p> <p>Note</p> <p>A Lie polynomial is a polynomial of the form \\( Y(t) = \\sum_{n &gt; 0} t^n Y_n \\), where the coefficients <code>Y_n</code> are members of the Lie algebra.</p>"},{"location":"api/#pulseseek.polynomial.LiePolynomial.evaluate","title":"evaluate","text":"<pre><code>evaluate(t)\n</code></pre> <p>Evaluate the polynomial using a Horner scheme</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>the independent variable</p> required <p>Returns:</p> Name Type Description <code>Vector</code> <code>LieVector</code> <p>the evaluated value</p> Source code in <code>pulseseek/polynomial.py</code> <pre><code>def evaluate(self, t: float) -&gt; LieVector:\n    \"\"\"Evaluate the polynomial using a Horner scheme\n\n    Args:\n        t (float): the independent variable\n\n    Returns:\n        Vector: the evaluated value\n    \"\"\"\n    if len(self.coeffs) &lt; 1:\n        raise ValueError(\"No coefficients\")\n    shape = self.coeffs[0].shape\n\n    z = jnp.zeros(shape, dtype=float)\n    assert is_vector(z)\n    for zn in reversed(self.coeffs):\n        z = zn + t * z\n    return t * z\n</code></pre>"},{"location":"api/#pulseseek.polynomial.BCHLiftingPlanTerm","title":"BCHLiftingPlanTerm  <code>dataclass</code>","text":"<pre><code>BCHLiftingPlanTerm(r, s, p, q, F)\n</code></pre> <p>A single BCH multilinear lifting term \\( F_{p, q}(X_r, Y_s) \\)</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>Array</code> <p>indices for the multilinear lifting of x</p> <code>s</code> <code>Array</code> <p>indices for the multilinear lifting of y</p> <code>p</code> <code>int</code> <p>the degree of the multilinear lifting of x</p> <code>q</code> <code>int</code> <p>the degree of the multilinear lifting of y</p> <code>F</code> <code>BCHLiftingMap</code> <p>the lifted BCH term function</p>"},{"location":"api/#pulseseek.polynomial.BCHLiftingPlanOrder","title":"BCHLiftingPlanOrder  <code>dataclass</code>","text":"<pre><code>BCHLiftingPlanOrder(order, terms)\n</code></pre> <p>Collection of all terms that contribute to order</p>"},{"location":"api/#pulseseek.polynomial.BCHLiftingPlan","title":"BCHLiftingPlan  <code>dataclass</code>","text":"<pre><code>BCHLiftingPlan(left_degree, right_degree, product_degree, orders)\n</code></pre> <p>Collection of all terms up to and including max_order</p>"},{"location":"api/#pulseseek.polynomial.lie_polynomial_adjoint_action","title":"lie_polynomial_adjoint_action  <code>cached</code>","text":"<pre><code>lie_polynomial_adjoint_action(algebra, atol=1e-12, max_terms=1000)\n</code></pre> <p>Compute the adjoint action / toggling transformation of a polynomial</p> <p>Note</p> <p>If <code>x</code> is a Lie algebra vector and <code>y(t)</code> is a Lie polynomial then</p> \\[ \\exp(x) y(t) \\exp(-x) = \\sum_n t^n Ad_{\\exp(x)} y_n = z(t) \\] <p>is the adjoint action of the polynomial.  The adjoint action of a polynomial is a polynomial formed from the adjoint action of each of the coefficients <code>y_n</code>.</p> <p>Parameters:</p> Name Type Description Default <code>algebra</code> <code>LieAlgebra</code> <p>the Lie algebra</p> required <code>atol</code> <code>float</code> <p>the absolute tolerance. Defaults to 1e-12.</p> <code>1e-12</code> <code>max_terms</code> <code>int</code> <p>the maximum number of terms. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>LiePolynomial</code> <code>Callable[[LieVector, LiePolynomial], LiePolynomial]</code> <p>the adjoint action</p> Source code in <code>pulseseek/polynomial.py</code> <pre><code>@functools.cache\ndef lie_polynomial_adjoint_action(\n    algebra: LieAlgebra, atol: float = 1e-12, max_terms: int = 1000\n) -&gt; Callable[[LieVector, LiePolynomial], LiePolynomial]:\n    \"\"\"Compute the adjoint action / toggling transformation of a polynomial\n\n    !!! note\n        If `x` is a Lie algebra vector and `y(t)` is a Lie polynomial then\n\n        $$ \\\\exp(x) y(t) \\\\exp(-x) = \\\\sum_n t^n Ad_{\\\\exp(x)} y_n = z(t) $$\n\n        is the adjoint action of the polynomial.  The adjoint action of a\n        polynomial is a polynomial formed from the adjoint action of each\n        of the coefficients `y_n`.\n\n    Args:\n        algebra (LieAlgebra): the Lie algebra\n        atol (float, optional): the absolute tolerance. Defaults to 1e-12.\n        max_terms (int, optional): the maximum number of terms. Defaults to\n            1000.\n\n    Returns:\n        LiePolynomial: the adjoint action\n    \"\"\"\n    ad = lie_adjoint_action(algebra, atol=atol, max_terms=max_terms)\n\n    @jax.jit\n    def adjoint_action_polynomial(x: LieVector, y: LiePolynomial) -&gt; LiePolynomial:\n        coeffs = tuple(ad(x, c) for c in y.coeffs)\n        return LiePolynomial(coeffs)\n\n    return adjoint_action_polynomial\n</code></pre>"},{"location":"api/#pulseseek.polynomial.lie_polynomial_bch_product","title":"lie_polynomial_bch_product  <code>cached</code>","text":"<pre><code>lie_polynomial_bch_product(algebra, left_degree=DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER, right_degree=DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER, product_degree=DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER)\n</code></pre> <p>Compile the BCH product between Lie polynomials</p> <p>Note</p> <p>Given two Lie polynomials <code>x(t)</code> and <code>y(t)</code>, their BCH product is defined as</p> \\[ log(exp(x(t)) exp(y(t))) = Z(x(t), y(t)) \\] <p>where <code>Z</code> is defined by the Baker-Campbell-Hausdorff series.</p> <p>Parameters:</p> Name Type Description Default <code>algebra</code> <code>LieAlgebra</code> <p>the Lie algebra</p> required <code>left_degree</code> <code>int</code> <p>the highest polynomial degree of the left argument <code>x(t)</code>.  Terms in <code>x(t)</code> higher than <code>left_degree</code> are ignored during the product. Defaults to <code>DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER</code>.</p> <code>DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER</code> <code>right_degree</code> <code>int</code> <p>the highest polynomial degree of the right argument <code>y(t)</code>.  Terms in <code>y(t)</code> higher than <code>right_degree</code> are ignored during the product. Defaults to <code>DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER</code></p> <code>DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER</code> <code>product_degree</code> <code>int</code> <p>the polynomial degree of the resulting polynomial product.  Terms higher than <code>product_degree</code> are ignored. Defaults to DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER.</p> <code>DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER</code> <p>Returns:</p> Name Type Description <code>LiePolynomialProduct</code> <code>LiePolynomialProduct</code> <p>the function computing the BCH product.</p> Source code in <code>pulseseek/polynomial.py</code> <pre><code>@functools.cache\ndef lie_polynomial_bch_product(\n    algebra: LieAlgebra,\n    left_degree: int = DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER,\n    right_degree: int = DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER,\n    product_degree: int = DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER,\n) -&gt; LiePolynomialProduct:\n    \"\"\"Compile the BCH product between Lie polynomials\n\n    !!! note\n        Given two Lie polynomials `x(t)` and `y(t)`, their BCH product is\n        defined as\n\n        $$ log(exp(x(t)) exp(y(t))) = Z(x(t), y(t)) $$\n\n        where `Z` is defined by the Baker-Campbell-Hausdorff series.\n\n    Args:\n        algebra (LieAlgebra): the Lie algebra\n        left_degree (int, optional): the highest polynomial degree of the\n            left argument `x(t)`.  Terms in `x(t)` higher than `left_degree`\n            are ignored during the product. Defaults to\n            `DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER`.\n        right_degree (int, optional): the highest polynomial degree of the\n            right argument `y(t)`.  Terms in `y(t)` higher than `right_degree`\n            are ignored during the product. Defaults to\n            `DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER`\n        product_degree (int, optional): the polynomial degree of the resulting\n            polynomial product.  Terms higher than `product_degree` are\n            ignored. Defaults to DEFAULT_LIE_POLYNOMIAL_PRODUCT_ORDER.\n\n    Returns:\n        LiePolynomialProduct: the function computing the BCH product.\n    \"\"\"\n    bracket = lie_bracket(algebra)\n    zero = algebra.basis.zero\n    Z = baker_campbell_hausdorff_compile(bracket, product_degree, \"lifting\")\n\n    # Build a static plan so there are no dict lookups inside jit.  Generally\n    # building the plan is O(n 2^n) complexity if all of the degrees equal n\n    plan = BCHLiftingPlan.new(Z, left_degree, right_degree, product_degree)\n\n    @jax.jit\n    def product(x: LiePolynomial, y: LiePolynomial) -&gt; LiePolynomial:\n        coeffs: list[LieVector] = []\n        for order_plan in plan.orders:\n            wn = zero\n            for term_plan in order_plan.terms:\n                xl = _lifting(x, term_plan.r)\n                yl = _lifting(y, term_plan.s)\n                F = term_plan.F\n                wn = wn + F(xl, yl)\n            coeffs.append(wn)\n        return LiePolynomial(tuple(coeffs))\n\n    return product\n</code></pre>"},{"location":"api/#pulseseek.system","title":"system","text":""},{"location":"api/#pulseseek.system.ControlSystem","title":"ControlSystem  <code>dataclass</code>","text":"<pre><code>ControlSystem(_H_drift, _H_controls, _H_error, _E_drift, _E_controls, _E_error, basis, algebra)\n</code></pre>"},{"location":"api/#pulseseek.system.ControlSystem.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(control_hamiltonians, error_hamiltonian, drift_hamiltonian=None, basis=None, inner_product=hilbert_schmidt_inner_product, bracket=matrix_commutator)\n</code></pre> <p>Construct a new control system</p> <p>Note</p> <p>A control system is a set of Hamiltonian operators of the form</p> \\[ H(u) = H_d + \\sum_i u_i H_i + \\epsilon H_e \\] <p>where <code>H_d</code>, <code>H_i</code>, and <code>H_e</code> are the drift Hamiltonian, control Hamiltonians, and error Hamiltonian respectively.  The strength of the error Hamiltonian <code>\\epsilon</code> is unknown.</p> <p>Alternatively, it is possible to represent the control system as a set of vectors on a Lie algebra</p> \\[ V(u) = V_d + \\sum_i u_i V_i + \\epsilon V_e \\] <p>where <code>V_d</code>, <code>V_i</code>, and <code>V_e</code> are the images of the Hamiltonains represented in the Lie algebra.</p> <p>Parameters:</p> Name Type Description Default <code>control_hamiltonians</code> <code>Iterable[Hermitian]</code> <p>the control Hamiltonians</p> required <code>error_hamiltonian</code> <code>Hermitian</code> <p>the error Hamiltonian</p> required <code>drift_hamiltonian</code> <code>Hermitian | None</code> <p>the drift Hamiltonian.  If not set, no drift is assumed.  Defaults to None.</p> <code>None</code> <code>basis</code> <code>LieBasis | None</code> <p>the Lie basis to use for the Lie algebra representation. If not provided, this method computes a basis from the Lie closure of the provided Hamiltonians. Defaults to None.</p> <code>None</code> <code>inner_product</code> <code>InnerProduct</code> <p>the inner product. Defaults to hilbert_schmidt_inner_product.</p> <code>hilbert_schmidt_inner_product</code> <code>bracket</code> <code>Bracket</code> <p>the Lie bracket. Defaults to matrix_commutator.</p> <code>matrix_commutator</code> <p>Returns:</p> Name Type Description <code>ControlSystem</code> <p>the control system</p> Source code in <code>pulseseek/system.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    control_hamiltonians: Iterable[Hermitian],\n    error_hamiltonian: Hermitian,\n    drift_hamiltonian: Hermitian | None = None,\n    basis: LieBasis | None = None,\n    inner_product: MatrixInnerProduct = hilbert_schmidt_inner_product,\n    bracket: MatrixBracket = matrix_commutator,\n):\n    \"\"\"Construct a new control system\n\n    !!! note\n        A control system is a set of Hamiltonian operators of the form\n\n        $$ H(u) = H_d + \\\\sum_i u_i H_i + \\\\epsilon H_e $$\n\n        where `H_d`, `H_i`, and `H_e` are the drift Hamiltonian, control\n        Hamiltonians, and error Hamiltonian respectively.  The strength\n        of the error Hamiltonian `\\\\epsilon` is unknown.\n\n        Alternatively, it is possible to represent the control system as\n        a set of vectors on a Lie algebra\n\n        $$ V(u) = V_d + \\\\sum_i u_i V_i + \\\\epsilon V_e $$\n\n        where `V_d`, `V_i`, and `V_e` are the images of the Hamiltonains\n        represented in the Lie algebra.\n\n    Args:\n        control_hamiltonians (Iterable[Hermitian]): the control\n            Hamiltonians\n        error_hamiltonian (Hermitian): the error Hamiltonian\n        drift_hamiltonian (Hermitian | None): the drift Hamiltonian.  If\n            not set, no drift is assumed.  Defaults to None.\n        basis (LieBasis | None): the Lie basis to use for the Lie algebra\n            representation. If not provided, this method computes a basis\n            from the Lie closure of the provided Hamiltonians. Defaults to\n            None.\n        inner_product (InnerProduct, optional): the inner product. Defaults\n            to hilbert_schmidt_inner_product.\n        bracket (Bracket, optional): the Lie bracket. Defaults to\n            matrix_commutator.\n\n    Returns:\n        ControlSystem: the control system\n    \"\"\"\n    H_controls = tuple(control_hamiltonians)\n\n    if basis is None:\n        # Construct a Lie basis from the Lie closure\n        Hd = {} if drift_hamiltonian is None else {\"Hd\": 1j * drift_hamiltonian}\n        Hc = {f\"Hc_{i}\": 1j * H for i, H in enumerate(H_controls)}\n        He = {\"He\": 1j * error_hamiltonian}\n        elements = {**Hd, **Hc, **He}\n        basis = lie_closure(elements, bracket=bracket)\n\n    algebra = lie_algebra(basis, inner_product, bracket)\n\n    def decomposition(x: Any) -&gt; LieVector:\n        def project(x: Any, y: SquareMatrix) -&gt; float:\n            assert is_anti_hermitian(x)\n            return inner_product(x, y)\n\n        g = jnp.array([project(x, y) for y in basis.elements])\n        v = jnp.linalg.solve(algebra.G, g)\n        assert is_vector(v)\n        return v\n\n    E_drift = (\n        None if drift_hamiltonian is None else decomposition(1j * drift_hamiltonian)\n    )\n    E_controls = tuple([decomposition(1j * H) for H in H_controls])\n    E_error = decomposition(1j * error_hamiltonian)\n\n    return cls(\n        _H_drift=drift_hamiltonian,\n        _H_controls=H_controls,\n        _H_error=error_hamiltonian,\n        _E_drift=E_drift,\n        _E_controls=E_controls,\n        _E_error=E_error,\n        basis=basis,\n        algebra=algebra,\n    )\n</code></pre>"},{"location":"api/#pulseseek.system.ControlSystem.control_hamiltonian","title":"control_hamiltonian","text":"<pre><code>control_hamiltonian(control)\n</code></pre> <p>Calculate the ideal (error free) Hamiltonian under the control</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>Vector</code> <p>the control vector</p> required <p>Returns:</p> Name Type Description <code>Hermitian</code> <code>Hermitian</code> <p>the ideal Hamiltonian</p> Source code in <code>pulseseek/system.py</code> <pre><code>def control_hamiltonian(self, control: Iterable[float]) -&gt; Hermitian:\n    \"\"\"Calculate the ideal (error free) Hamiltonian under the control\n\n    Args:\n        control (Vector): the control vector\n\n    Returns:\n        Hermitian: the ideal Hamiltonian\n    \"\"\"\n    H = np.zeros(self._H_error.shape, dtype=complex)\n\n    if self._H_drift is not None:\n        H += self._H_drift\n    for u, Hu in zip(control, self._H_controls):\n        H += u * Hu\n\n    assert is_hermitian(H)\n    return H\n</code></pre>"},{"location":"api/#pulseseek.system.ControlSystem.control_lie_vector","title":"control_lie_vector","text":"<pre><code>control_lie_vector(control)\n</code></pre> <p>Calculate the image of the ideal Hamiltonian in the Lie algebra</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>Vector</code> <p>the control vector</p> required <p>Returns:</p> Name Type Description <code>Vector</code> <code>LieVector</code> <p>the Lie algebra representation of the ideal Hamiltonian</p> Source code in <code>pulseseek/system.py</code> <pre><code>def control_lie_vector(self, control: Iterable[float]) -&gt; LieVector:\n    \"\"\"Calculate the image of the ideal Hamiltonian in the Lie algebra\n\n    Args:\n        control (Vector): the control vector\n\n    Returns:\n        Vector: the Lie algebra representation of the ideal Hamiltonian\n    \"\"\"\n    m = self.basis.dim\n    v = np.zeros((m,), dtype=float)\n\n    if self._E_drift is not None:\n        v += self._E_drift\n\n    for u, Eu in zip(control, self._E_controls):\n        v += u * Eu\n    assert is_vector(v, dimension=m)\n    return v\n</code></pre>"},{"location":"api/#pulseseek.types","title":"types","text":""},{"location":"api/#pulseseek.types.is_scalar","title":"is_scalar","text":"<pre><code>is_scalar(x)\n</code></pre> <p>Check if x is a Scalar</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>the object to check</p> required <p>Returns:</p> Type Description <code>TypeGuard[Scalar]</code> <p>TypeGuard[Scalar]: whether the object is a scalar</p> Source code in <code>pulseseek/types.py</code> <pre><code>def is_scalar(x: Any) -&gt; TypeGuard[Scalar]:\n    \"\"\"Check if x is a Scalar\n\n    Args:\n        x (Any): the object to check\n\n    Returns:\n        TypeGuard[Scalar]: whether the object is a scalar\n    \"\"\"\n    if hasattr(x, \"shape\"):\n        return x.shape == (1,)\n    if isinstance(x, (float, complex)):\n        return True\n    return False\n</code></pre>"},{"location":"api/#pulseseek.types.is_vector","title":"is_vector","text":"<pre><code>is_vector(x, *, dimension=None)\n</code></pre> <p>Check if x is a vector</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>the object to check</p> required <code>dimension</code> <code>int | None</code> <p>the vector dimension. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TypeGuard[LieVector]</code> <p>TypeGuard[Vector]: whether x is a vector</p> Source code in <code>pulseseek/types.py</code> <pre><code>def is_vector(x: Any, *, dimension: int | None = None) -&gt; TypeGuard[LieVector]:\n    \"\"\"Check if x is a vector\n\n    Args:\n        x (Any): the object to check\n        dimension (int | None): the vector dimension. Defaults to None.\n\n    Returns:\n        TypeGuard[Vector]: whether x is a vector\n    \"\"\"\n    if not isinstance(x, jax.Array):\n        return False\n    if x.ndim != 1:\n        return False\n    m = x.shape[0]\n    if dimension and m != dimension:\n        return False\n    return True\n</code></pre>"},{"location":"api/#pulseseek.types.is_matrix","title":"is_matrix","text":"<pre><code>is_matrix(x, *, shape=None)\n</code></pre> <p>Check if x is a matrix</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>the object to check</p> required <code>shape</code> <code>tuple[int, int] | None</code> <p>the required matrix shape. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TypeGuard[Matrix]</code> <p>TypeGuard[Matrix]: whether the object is a matrix</p> Source code in <code>pulseseek/types.py</code> <pre><code>def is_matrix(x: Any, *, shape: tuple[int, int] | None = None) -&gt; TypeGuard[Matrix]:\n    \"\"\"Check if x is a matrix\n\n    Args:\n        x (Any): the object to check\n        shape (tuple[int, int] | None): the required matrix shape. Defaults to None.\n\n    Returns:\n        TypeGuard[Matrix]: whether the object is a matrix\n    \"\"\"\n    if not isinstance(x, jax.Array):\n        return False\n    if x.ndim != 2:\n        return False\n    if shape and x.shape != shape:\n        return False\n    return True\n</code></pre>"},{"location":"api/#pulseseek.types.is_tensor","title":"is_tensor","text":"<pre><code>is_tensor(x, *, shape=None)\n</code></pre> <p>Check if x is a tensor</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>the object to check</p> required <code>shape</code> <code>tuple[int, ...] | None</code> <p>the required tensor shape. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TypeGuard[Tensor]</code> <p>TypeGuard[Tensor]: whether the object is a tensor</p> Source code in <code>pulseseek/types.py</code> <pre><code>def is_tensor(x: Any, *, shape: tuple[int, ...] | None = None) -&gt; TypeGuard[Tensor]:\n    \"\"\"Check if x is a tensor\n\n    Args:\n        x (Any): the object to check\n        shape (tuple[int, ...] | None): the required tensor shape. Defaults to None.\n\n    Returns:\n        TypeGuard[Tensor]: whether the object is a tensor\n    \"\"\"\n    if not isinstance(x, jax.Array):\n        return False\n    if shape and x.shape != shape:\n        return False\n    return True\n</code></pre>"},{"location":"api/#pulseseek.types.is_antisymmetric_tensor","title":"is_antisymmetric_tensor","text":"<pre><code>is_antisymmetric_tensor(x, *, dimension=None, atol=1e-12)\n</code></pre> <p>Check if x is an anti-symmetric rank-3 tensor</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>the object to check</p> required <code>dimension</code> <code>int | None</code> <p>the tensor dimension. Defaults to None.</p> <code>None</code> <code>atol</code> <code>float</code> <p>the absolute tolerance. Defaults to 1e-12.</p> <code>1e-12</code> <p>Returns:</p> Type Description <code>TypeGuard[AntiSymmetricTensor]</code> <p>TypeGuard[AntiSymmetricTensor]: whether the object is an anti-symmetric tensor</p> Source code in <code>pulseseek/types.py</code> <pre><code>def is_antisymmetric_tensor(\n    x: Any, *, dimension: int | None = None, atol: float = 1e-12\n) -&gt; TypeGuard[AntiSymmetricTensor]:\n    \"\"\"Check if x is an anti-symmetric rank-3 tensor\n\n    Args:\n        x (Any): the object to check\n        dimension (int | None): the tensor dimension. Defaults to None.\n        atol (float, optional): the absolute tolerance. Defaults to 1e-12.\n\n    Returns:\n        TypeGuard[AntiSymmetricTensor]: whether the object is an anti-symmetric\n            tensor\n    \"\"\"\n    if not isinstance(x, jax.Array):\n        return False\n    if x.ndim != 3:\n        return False\n\n    m = dimension if dimension else x.shape[0]\n    if not x.shape == (m, m, m):\n        return False\n    for a in range(m):\n        if not np.allclose(x[a], -x[a].T, atol=atol):\n            return False\n    return True\n</code></pre>"},{"location":"api/#pulseseek.util","title":"util","text":""},{"location":"api/#pulseseek.util.pauli","title":"pauli","text":"<pre><code>pauli()\n</code></pre> <p>Return the Pauli matrices</p> <p>Returns:</p> Type Description <code>tuple[Hermitian, Hermitian, Hermitian]</code> <p>tuple[Hermitian, Hermitian, Hermitian]: the Pauli matrices.</p> Source code in <code>pulseseek/util.py</code> <pre><code>def pauli() -&gt; tuple[Hermitian, Hermitian, Hermitian]:\n    \"\"\"Return the Pauli matrices\n\n    Returns:\n        tuple[Hermitian, Hermitian, Hermitian]: the Pauli matrices.\n    \"\"\"\n    X = jnp.array([[0, 1], [1, 0]])\n    Y = jnp.array([[0, -1j], [1j, 0]])\n    Z = jnp.array([[1, 0], [0, -1]])\n\n    assert is_hermitian(X)\n    assert is_hermitian(Y)\n    assert is_hermitian(Z)\n\n    return X, Y, Z\n</code></pre>"},{"location":"api/#pulseseek.util.sumsto","title":"sumsto","text":"<pre><code>sumsto(total, degree, skip_zero=True)\n</code></pre> <p>Iterate over tuples of length <code>degree</code> that sum to <code>total</code>.</p> <p>Parameters:</p> Name Type Description Default <code>total</code> <code>int</code> <p>the total sum of the tuple</p> required <code>degree</code> <code>int</code> <p>the length of the tuple</p> required <p>Yields:</p> Type Description <code>tuple[int, ...]</code> <p>Iterator[tuple[int, ...]]: the sequence of tuples</p> Source code in <code>pulseseek/util.py</code> <pre><code>def sumsto(\n    total: int, degree: int, skip_zero: bool = True\n) -&gt; Iterator[tuple[int, ...]]:\n    \"\"\"Iterate over tuples of length `degree` that sum to `total`.\n\n    Args:\n        total (int): the total sum of the tuple\n        degree (int): the length of the tuple\n\n    Yields:\n        Iterator[tuple[int, ...]]: the sequence of tuples\n    \"\"\"\n    if degree &lt;= 0 or total &lt;= 0:\n        return\n\n    offset = 0 if skip_zero else 1\n    for cuts in combinations(range(1 - offset, total + offset), degree - 1):\n        parts = [a - b for a, b in zip(cuts + (total,), (0,) + cuts)]\n        yield tuple(parts)\n</code></pre>"},{"location":"theory/","title":"Theory","text":"<p><code>pulseseek</code> uses a Lie algebraic representation to solve certain optimization problems in quantum control theory.  Unlike matrix based representations, most of the numerical code in this library works on a vector representation of the Lie algebra.</p> <p>We strongly encourage users to formally study Lie theory to develop a solid understanding of the underlying mathematics.  This short exposure summarizes some of the key theoretical results that <code>pulseseek</code> uses in it's implementation.</p>"},{"location":"theory/#lie-theory","title":"Lie theory","text":"<p>Let \\( \\mathfrak{g} \\) denote a Lie algebra, and let  \\( \\mathfrak{G} = \\exp(\\mathfrak{g}) \\) denote its corresponding Lie group.  By definition, a Lie algebra  \\( \\mathfrak{g} \\) is a vector space that is also closed under a bilinear  operation called the Lie bracket, denoted by \\([\\,\\cdot\\,,\\,\\cdot\\,]\\). Formally,</p> \\[ [x, y] \\in \\mathfrak{g} \\quad \\text{for all} \\quad x, y \\in \\mathfrak{g}. \\] <p>The Lie bracket is bilinear and satisfies the Jacobi identity, two properties that endow \\( \\mathfrak{g} \\) with a rich algebraic structure closely related to smooth transformations in \\( \\mathfrak{G} \\).  We further assume that \\( \\mathfrak{g} \\) is equipped with an inner product \\( \\langle \\cdot , \\cdot \\rangle \\) and the corresponding norm \\( || \\cdot || \\). These provide the algebra with a geometric structure,  allowing projection, orthogonality, and numerical stability in computations.</p> <p>The exponential map</p> \\[ \\exp : \\mathfrak{g} \\rightarrow \\mathfrak{G} \\] <p>provides a local correspondence between the algebra and its Lie group.  Through this map, any group element \\( X \\in \\mathfrak{G} \\) near the identity can be expressed as \\( X = \\exp(x) \\) for some \\( x \\in \\mathfrak{g} \\).  The vector \\( x \\) thus serves as a local coordinate for the group element \\( X \\), allowing  computations on \\( \\mathfrak{G} \\) to be carried out in the (typically simpler) vector space \\( \\mathfrak{g} \\).</p>"},{"location":"theory/#algebra-structure","title":"Algebra structure","text":"<p>Let \\(E = \\{ e_1, e_2, \\cdots, e_m \\} \\) be a basis for the algebra \\( \\mathfrak{g} \\).  Because both the Lie bracket and inner product are bilinear, their complete behavior is determined by their action on the basis elements.</p> <p>The structure constants of the algebra are the coefficients \\( F_{ijk} \\in \\mathbb{R} \\) (or \\( \\mathbb{C} \\)) defined by the expansion</p> \\[ [e_i, e_j] = \\sum_{k=1}^{m} F_{ijk} \\, e_k. \\] <p>The structure constants form a rank-3 antisymmetric tensor.</p> <p>Similarly the Gram matrix contains coefficients \\( G_{ij} \\in \\mathbb{R} \\) (or \\( \\mathbb{C} \\)) defined by</p> \\[ \\langle e_i, e_j \\rangle = G_{ij} \\] <p>The Gram matrix is a Hermitian matrix that encodes the metric structure of  \\( \\mathfrak{g} \\).  When the basis is orthonormal, \\( G_{ij} = \\delta_{ij} \\),  and the inner product simplifies to the usual Euclidean form.  For  non-orthonormal bases, \\( G_{ij} \\) allows the computation of inner products, norms, and projections.</p>"},{"location":"theory/#numeric-representation","title":"Numeric representation","text":"<p>In <code>pulseseek</code>, the Lie algebra is represented numerically by the tuple \\( (G, F) \\), where \\( G \\) is the Gram matrix defining the inner product and \\( F \\) is the structure constant tensor defining the Lie bracket.  All computations involving inner products or commutators are performed using these tensors.</p> <p>This representation enables a simple vector-based implementation of Lie algebra elements, while remaining fully consistent with their corresponding matrix representations in cases where \\( \\mathfrak{g} \\) is a matrix Lie algebra.</p>"},{"location":"theory/#bch-formulas","title":"BCH formulas","text":"<p>The Baker-Campbell-Hausdorff (BCH) map is the function \\(Z : \\mathfrak{g} \\times \\mathfrak{g} \\to \\mathfrak{g} \\), satisfying</p> \\[ \\exp\\!\\big(Z(x,y)\\big) = \\exp(x)\\,\\exp(y), \\qquad x,y \\in \\mathfrak{g}. \\] <p>The map \\( Z \\) admits a formal expansion in the noncommuting variables \\( x \\) and \\( y \\):</p> \\[ Z(x,y) = \\sum_{k=1}^{\\infty} Z_k(x,y), \\] <p>where each \\(Z_k : \\mathfrak{g} \\times \\mathfrak{g} \\to \\mathfrak{g}\\) is a homogeneous Lie polynomial of total degree \\(k\\), that is, a \\(k\\)-linear combination of nested Lie brackets containing exactly \\(k\\) occurrences of \\(x\\) and \\(y\\) in total.  Each homogeneous term \\(Z_k\\) can be decomposed further according to the number of occurrences of \\(x\\) and \\(y\\):</p> \\[ Z_k(x,y) = \\sum_{\\substack{p,q \\ge 0 \\\\ p+q = k}} Z_{(p,q)}(x,y), \\] <p>where \\(Z_{(p,q)}\\) denotes the component of bidegree \\((p,q)\\), formed by all monomials with \\(p\\) copies of \\(x\\) and \\(q\\) copies of \\(y\\).  </p> <p>Explicit formulas for \\(Z_k\\) are well known, but at high order these quickly become algebraically complex and difficult to work with.  <code>pulseseek</code> stores pre-computed algebraic terms for \\(Z_{(p,q)}\\) up to order \\(p + q \\leq 15 \\).  At runtime, these exact algebraic expressions are compiled using <code>jax.jit</code> into efficient and automatically differentiable machine code that can be executed on GPUs and other hardware.</p>"},{"location":"theory/#table-of-z_pq","title":"Table of \\(Z_{(p,q)}\\)","text":"Total degree Bidegree \\((p, q)\\) \\(Z_{(p,q)}(x, y)\\) 1 (1, 0) \\( x \\) (0, 1) \\( y \\) 2 (1, 1) \\( \\tfrac{1}{2} [x, y]\\) 3 (2, 1) \\( \\tfrac{1}{12} [x,[x,y]]\\) (1, 2) \\( \\tfrac{1}{12} [y,[y,x]]\\) 4 (2, 2) \\( -\\tfrac{1}{24}[y,[x,[x,y]]]\\) 5 (4, 1) \\( -\\tfrac{1}{720}[x,[x,[x,[x,y]]]]\\) (3, 2) \\( \\tfrac{1}{180}[x, [x, [[x, y], y]]] + \\tfrac{1}{360}[[x, [x,y]], [x,y]] \\) (2, 3) \\( \\tfrac{1}{180}[x,[[[x,y], y], y]] + \\tfrac{1}{120}[[x,y], [[x,y],y]] \\) (1, 4) \\( -\\tfrac{1}{720}[[[[x,y],y],y],y] \\)"},{"location":"theory/#multilinear-lifting","title":"Multilinear lifting","text":"<p>Although \\(Z_{(p,q)}(x,y)\\) depends on only two arguments, it is multilinear in the \\(p\\) appearances of \\(x\\) and the \\(q\\) appearances of \\(y\\) within each monomial of bidegree \\((p,q)\\). To make this structure explicit, we introduce a corresponding multilinear map</p> \\[ \\mathcal{F}_{(p,q)} : \\underbrace{\\mathfrak{g} \\times \\cdots \\times \\mathfrak{g}}_{p\\ \\text{copies}} \\times \\underbrace{\\mathfrak{g} \\times \\cdots \\times \\mathfrak{g}}_{q\\ \\text{copies}} \\longrightarrow \\mathfrak{g}, \\] <p>such that the symmetric specialization</p> \\[ Z_{(p,q)}(x,y) = \\mathcal{F}_{(p,q)}\\!\\left( \\underbrace{x, x, \\dots, x}_{p\\ \\text{copies}};\\, \\underbrace{y, y, \\dots, y}_{q\\ \\text{copies}} \\right) \\] <p>recovers the original bidegree-\\((p,q)\\) term.</p> <p>The map \\(\\mathcal{F}_{(p,q)}\\) is multilinear in each argument and obeys the scaling law</p> \\[ \\mathcal{F}_{(p,q)}(a x_1, \\ldots, a x_p;\\, b y_1, \\ldots, b y_q) = a^{p} b^{q}\\, \\mathcal{F}_{(p,q)}(x_1, \\ldots, x_p;\\, y_1, \\ldots, y_q). \\] <p>for any two scalars \\(a\\) and \\(b\\). This \u201clifted\u201d representation of \\(Z_{(p,q)}\\) makes it possible to evaluate each BCH component on distinct inputs for its \\(x\\)- and \\(y\\)-slots.</p>"},{"location":"theory/#lie-polynomials","title":"Lie polynomials","text":"<p>A Lie polynomial with coefficients in \\(\\mathfrak{g}\\) is a formal power series whose coefficients are elements of \\(\\mathfrak{g}\\):</p> \\[ y(t) = \\sum_{n \\ge 1} t^{n}\\, y_n, \\] <p>where each \\(y_n \\in \\mathfrak{g}\\) and \\(t\\) is a formal commuting parameter. Such a series represents a formal curve in the Lie algebra, with coefficients \\(\\{y_n\\}\\) describing its successive orders of variation.</p>"},{"location":"theory/#bch-formulas_1","title":"BCH formulas","text":"<p>Let \\(x(t)\\) and \\(y(t)\\) be Lie polynomials with coefficients in \\(\\mathfrak{g}\\):</p> \\[ x(t) = \\sum_{r \\ge 1} t^{r}\\, x_r, \\qquad y(t) = \\sum_{s \\ge 1} t^{s}\\, y_s, \\] <p>where \\(x_r, y_s \\in \\mathfrak{g}\\). We define their BCH composition by</p> \\[ w(t) = Z\\!\\big(x(t),\\, y(t)\\big) = \\log\\!\\big(\\exp(x(t))\\, \\exp(y(t))\\big), \\] <p>where \\(Z\\) is the BCH map defined above.  The function \\(w(t)\\) is itself a Lie polynomial.  We show this by substituting the BCH map with its multilinear lifting</p> \\[ w(t) = \\sum_{p,q \\ge 0} \\mathcal{F}_{(p,q)}\\!\\left( \\underbrace{x(t),\\ldots,x(t)}_{p\\ \\text{copies}};\\, \\underbrace{y(t),\\ldots,y(t)}_{q\\ \\text{copies}} \\right). \\] <p>Then by repeatedly substituting the power series for \\(x(t)\\) and \\(y(t)\\) and grouping terms by powers of \\(t\\), the result takes the polynomial form  \\(w(t) = \\sum_{n \\geq 1} t^n w_n\\) where the coefficients are</p> \\[ w_n = \\sum_{\\substack{p,q \\ge 0 \\\\ r_1+\\cdots+r_p+s_1+\\cdots+s_q = n}} \\mathcal{F}_{(p,q)}(x_{r_1},\\ldots,x_{r_p}; y_{s_1},\\ldots,y_{s_q}). \\]"},{"location":"theory/#table-of-w_n","title":"Table of \\(w_n\\)","text":"\\(n\\) \\(w_n\\) 1 \\( w_1 = x_1 + y_1 \\) 2 \\( w_2 = x_2 + y_2 + \\tfrac{1}{2}[x_1, y_1] \\) 3 \\( w_3 = x_3 + y_3 + \\tfrac{1}{2}([x_1, y_2] + [x_2, y_1]) + \\tfrac{1}{12}\\big([x_1,[x_1,y_1]] + [y_1,[y_1,x_1]]\\big) \\) 4 \\( \\begin{aligned} w_4 &amp;= x_4 + y_4 + \\tfrac{1}{2}([x_1, y_3] + [x_2, y_2] + [x_3, y_1]) \\\\ &amp;\\quad + \\tfrac{1}{12}\\big([x_1,[x_1,y_2]] + [x_1,[x_2,y_1]] + [x_2,[x_1,y_1]] \\\\ &amp;\\qquad\\quad + [y_1,[y_1,x_2]] + [y_1,[y_2,x_1]] + [y_2,[y_1,x_1]]\\big) \\\\ &amp;\\quad - \\tfrac{1}{24}[y_1,[x_1,[x_1,y_1]]] \\end{aligned} \\)"},{"location":"theory/#pulse-sequences","title":"Pulse sequences","text":"<p>This BCH construction provides a systematic way to compute Lie group products of the form \\( e^{x(t)} e^{y(t)} = e^{w(t)} \\) while remaining entirely within a polynomial representation of the Lie algebra.  </p> <p>One of the primary goals of <code>pulseseek</code> is to develop an optimization framework capable of discovering nontrivial sequences of Lie algebra elements \\( x_1, x_2, \\ldots, x_L \\) such that</p> \\[ e^{w(t)} = e^{t x_L} \\cdots e^{t x_2} e^{t x_1} = \\prod_{\\ell = 1}^{L} \\exp(t x_\\ell), \\] <p>and where \\( w_n = 0 \\) for all \\( n \\leq N \\).  We refer to such a construction as an \\(\\mathcal{O}(N)\\) compensating pulse sequence of length \\( L \\).</p>"}]}